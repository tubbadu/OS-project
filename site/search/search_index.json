{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"OS Project This project is a Linux kernel module designed to perform Fast Fourier Transform (FFT). It is then used on an audio signal in order to determine the corresponding musical note. By integrating this functionality directly into the kernel, the module enables efficient real-time frequency analysis, making it suitable for applications in audio signal processing, musical analysis, and embedded systems. The implementation is optimized for execution in an emulated environment using QEMU and Buildroot, ensuring flexibility and portability across different hardware platforms. For environment setup instructions, refer to the Setup.md file. Detailed explanations of the kernel module, see Kernel_module.md . To learn more about the modifications made to QEMU for custom HW emulation, check Qemu.md . You can find the complete repository on GitHub .","title":"OS Project"},{"location":"#os-project","text":"This project is a Linux kernel module designed to perform Fast Fourier Transform (FFT). It is then used on an audio signal in order to determine the corresponding musical note. By integrating this functionality directly into the kernel, the module enables efficient real-time frequency analysis, making it suitable for applications in audio signal processing, musical analysis, and embedded systems. The implementation is optimized for execution in an emulated environment using QEMU and Buildroot, ensuring flexibility and portability across different hardware platforms. For environment setup instructions, refer to the Setup.md file. Detailed explanations of the kernel module, see Kernel_module.md . To learn more about the modifications made to QEMU for custom HW emulation, check Qemu.md . You can find the complete repository on GitHub .","title":"OS Project"},{"location":"Kernel_module/","text":"Kernel Module Documentation: FFT Core 1. Introduction This document describes the Linux kernel module developed to compute the Fast Fourier Transform (FFT) . The module has been tested in an emulated environment using QEMU and Buildroot . 2. Requirements TODO Linux kernel compiled with support for custom module. Buildroot configured to include the necessary libraries. Test environment emulated with QEMU, modified to support the custom hardware. 3. Features TODO: rivedere Memory Allocation: Processes 128 complex input values (each 64-bit) and produces 128 complex output values. System Calls Handling: Provides an interface for process interaction with the OS. User space library: Included user space library to ease the interface with the kernel module. FFT Signal Processing: Implements FFT algorithm for signal analysis. 4. Kernel Module Implementation 4.1 Code Structure The Kernel module is organized into the following main sections: Initialization : Registering the module in the kernel and allocating necessary resources. FFT Processing : Using the Cooley-Tukey FFT method, the module computes the FFT of the input signal. Due to the nature of the algorithm, only input sizes that are powers of two are allowed. Interface: The module comunicates with the User through the ioctl function. 4.2 FFT Functionality This algorithm implements the Fast Fourier Transform (FFT) using an iterative approach optimized for input sizes that are powers of two. Below is a brief description of its key components: Sample Count Adjustment ( getNSAMPLES ) Ensures the number of samples is the next power of two. Logarithm Base 2 Calculation ( ilog2 ) Computes the integer logarithm base 2 of a given number, used to determine the number of FFT stages. Power of Two Check ( check ) Verifies if the input size is a power of two, a requirement for the Cooley-Tukey FFT algorithm. Bit-Reversal ( reverse ) Computes the bit-reversed index of an integer, essential for reordering elements before applying the FFT. Reordering the Input ( sort ) Reorders the input vector based on bit-reversed indices to optimize the FFT computation. FFT Computation ( transform ) Uses the iterative Cooley-Tukey FFT method. Initializes a set of complex roots of unity (twiddle factors). Applies a series of butterfly operations to iteratively compute the FFT. Final FFT Transformation ( FFT ) Calls transform() and scales the output by the step size. This implementation is designed for efficiency and correctness in FFT-based frequency analysis. 5. Compilation and Installation To correctly compile and install the module please refer to the README.md file 6. Testing on QEMU and Buildroot The correctness of the kernel module was verified using fft_test.c . The output was compared with the results obtained from the same algorithm running without the custom hardware. 7. Verification of FFT Results Using MATLAB To ensure the correctness of the results produced by the module, we used MATLAB as a reference tool to compute the Fast Fourier Transform (FFT) of test signals. MATLAB's FFT implementation is highly reliable and widely used in scientific and engineering applications, making it an excellent benchmark for comparison. Validation with Lab-created Samples Test Signal Generation : We generated synthetic test signals in MATLAB, such as sine waves. Example of a 440 Hz sine wave generation: Fs = 1500; % Sampling frequency (1 kHz) t = 0:1/Fs:1-1/Fs; % Time vector (1 second) f = 440; % Frequency of the sine wave (50 Hz) signal = sin(2 * pi * f * t); % Generate the sine wave FFT Computation in MATLAB : We computed the FFT of the test signal using MATLAB's built-in fft function. Example: fft_result_matlab = fft(signal); % Compute the FFT fft_magnitude_matlab = abs(fft_result_matlab); % Get the magnitude frequencies = (0:length(fft_result_matlab)-1) * Fs / length(fft_result_matlab); % Frequency axis FFT Computation in the Module : The same test signal was processed by the module to compute the FFT. The module's output was saved for comparison. Comparison of Results : TODO We compared the FFT results from MATLAB and the module element by element . We calculated the absolute difference between corresponding frequency bins: difference = abs(fft_magnitude_matlab - fft_magnitude_module); mse = mean(difference.^2); % Mean Squared Error fprintf('Mean Squared Error: %f\\n', mse); A tolerance threshold was defined to account for minor numerical differences due to floating-point precision or implementation-specific optimizations. Visualization : We plotted the FFT results from both MATLAB and the module to visually inspect the agreement. Example: plot(frequencies, fft_magnitude_matlab, 'b', 'LineWidth', 1.5); % MATLAB FFT hold on; plot(frequencies, fft_magnitude_module, 'r--', 'LineWidth', 1.5); % Module FFT xlabel('Frequency (Hz)'); ylabel('Magnitude'); legend('MATLAB FFT', 'Module FFT'); title('Comparison of FFT Results'); grid on; Validation Metrics : Mean Squared Error (MSE) : Computed to quantify the difference between the two FFT outputs. Frequency Bin Accuracy : Ensured that the dominant frequencies identified by the module matched those identified by MATLAB. Edge Case Testing : We tested the module with various edge cases, such as: Signals with very low or very high amplitudes. Signals with a single frequency component. Signals with added noise to simulate real-world conditions. These tests ensured that the module behaves correctly under a wide range of scenarios. Automated Testing : We developed a MATLAB script to automate the verification process for multiple test signals. This script generates signals, computes the FFT, compares the results, and logs the metrics. Validation with Real-World Samples We then extended our validation process to real-world audio samples , following the same rigorous procedure to ensure the efficiency and accuracy of our module. This step was crucial to verify the module's performance in practical scenarios, where signals often contain noise, harmonics, and other complexities not present in synthetic test cases. Real-World Signal Acquisition : We captured real audio samples using a high-quality microphone and preprocessed them to match the module's input requirements. Examples of samples included musical notes played on various instruments, voice recordings, and environmental sounds. FFT Computation and Comparison : We computed the FFT of these real-world samples using both MATLAB (as the reference) and our module. The results were compared using the same metrics as before: Mean Squared Error (MSE) , and frequency bin accuracy . Observations : The module demonstrated high accuracy for higher frequencies (e.g., notes above C1), with results closely matching those from MATLAB. However, we observed a slightly higher error margin for very low frequencies (e.g., notes in the range C0 to B0). This is likely due to the inherent challenges in accurately resolving low-frequency components with limited sample sizes and the sensitivity of the FFT algorithm at lower frequency ranges. Conclusion on Accuracy : Despite the minor discrepancies at lower frequencies, the module's performance was deemed highly accurate for the majority of the frequency spectrum, particularly in the range most relevant for musical note recognition. The observed errors at lower frequencies are within acceptable limits for our target applications, and we are exploring potential optimizations to further improve accuracy in this range. Future Improvements We plan to add the support to perfom also the inverse fft We plan to investigate techniques to enhance the module's accuracy for very low frequencies , such as: Increasing the sample size or sampling rate. Applying advanced windowing functions to reduce spectral leakage. Incorporating post-processing algorithms to refine frequency detection. This thorough validation process, using both synthetic and real-world signals, confirms that our module is reliable and accurate for its intended applications, with only minor limitations at the extreme low end of the frequency spectrum.","title":"Kernel Module Documentation: FFT Core"},{"location":"Kernel_module/#kernel-module-documentation-fft-core","text":"","title":"Kernel Module Documentation: FFT Core"},{"location":"Kernel_module/#1-introduction","text":"This document describes the Linux kernel module developed to compute the Fast Fourier Transform (FFT) . The module has been tested in an emulated environment using QEMU and Buildroot .","title":"1. Introduction"},{"location":"Kernel_module/#2-requirements-todo","text":"Linux kernel compiled with support for custom module. Buildroot configured to include the necessary libraries. Test environment emulated with QEMU, modified to support the custom hardware.","title":"2. Requirements TODO"},{"location":"Kernel_module/#3-features-todo-rivedere","text":"Memory Allocation: Processes 128 complex input values (each 64-bit) and produces 128 complex output values. System Calls Handling: Provides an interface for process interaction with the OS. User space library: Included user space library to ease the interface with the kernel module. FFT Signal Processing: Implements FFT algorithm for signal analysis.","title":"3. Features TODO: rivedere"},{"location":"Kernel_module/#4-kernel-module-implementation","text":"","title":"4. Kernel Module Implementation"},{"location":"Kernel_module/#41-code-structure","text":"The Kernel module is organized into the following main sections: Initialization : Registering the module in the kernel and allocating necessary resources. FFT Processing : Using the Cooley-Tukey FFT method, the module computes the FFT of the input signal. Due to the nature of the algorithm, only input sizes that are powers of two are allowed. Interface: The module comunicates with the User through the ioctl function.","title":"4.1 Code Structure"},{"location":"Kernel_module/#42-fft-functionality","text":"This algorithm implements the Fast Fourier Transform (FFT) using an iterative approach optimized for input sizes that are powers of two. Below is a brief description of its key components: Sample Count Adjustment ( getNSAMPLES ) Ensures the number of samples is the next power of two. Logarithm Base 2 Calculation ( ilog2 ) Computes the integer logarithm base 2 of a given number, used to determine the number of FFT stages. Power of Two Check ( check ) Verifies if the input size is a power of two, a requirement for the Cooley-Tukey FFT algorithm. Bit-Reversal ( reverse ) Computes the bit-reversed index of an integer, essential for reordering elements before applying the FFT. Reordering the Input ( sort ) Reorders the input vector based on bit-reversed indices to optimize the FFT computation. FFT Computation ( transform ) Uses the iterative Cooley-Tukey FFT method. Initializes a set of complex roots of unity (twiddle factors). Applies a series of butterfly operations to iteratively compute the FFT. Final FFT Transformation ( FFT ) Calls transform() and scales the output by the step size. This implementation is designed for efficiency and correctness in FFT-based frequency analysis.","title":"4.2 FFT Functionality"},{"location":"Kernel_module/#5-compilation-and-installation","text":"To correctly compile and install the module please refer to the README.md file","title":"5. Compilation and Installation"},{"location":"Kernel_module/#6-testing-on-qemu-and-buildroot","text":"The correctness of the kernel module was verified using fft_test.c . The output was compared with the results obtained from the same algorithm running without the custom hardware.","title":"6. Testing on QEMU and Buildroot"},{"location":"Kernel_module/#7-verification-of-fft-results-using-matlab","text":"To ensure the correctness of the results produced by the module, we used MATLAB as a reference tool to compute the Fast Fourier Transform (FFT) of test signals. MATLAB's FFT implementation is highly reliable and widely used in scientific and engineering applications, making it an excellent benchmark for comparison.","title":"7. Verification of FFT Results Using MATLAB"},{"location":"Kernel_module/#validation-with-lab-created-samples","text":"Test Signal Generation : We generated synthetic test signals in MATLAB, such as sine waves. Example of a 440 Hz sine wave generation: Fs = 1500; % Sampling frequency (1 kHz) t = 0:1/Fs:1-1/Fs; % Time vector (1 second) f = 440; % Frequency of the sine wave (50 Hz) signal = sin(2 * pi * f * t); % Generate the sine wave FFT Computation in MATLAB : We computed the FFT of the test signal using MATLAB's built-in fft function. Example: fft_result_matlab = fft(signal); % Compute the FFT fft_magnitude_matlab = abs(fft_result_matlab); % Get the magnitude frequencies = (0:length(fft_result_matlab)-1) * Fs / length(fft_result_matlab); % Frequency axis FFT Computation in the Module : The same test signal was processed by the module to compute the FFT. The module's output was saved for comparison. Comparison of Results : TODO We compared the FFT results from MATLAB and the module element by element . We calculated the absolute difference between corresponding frequency bins: difference = abs(fft_magnitude_matlab - fft_magnitude_module); mse = mean(difference.^2); % Mean Squared Error fprintf('Mean Squared Error: %f\\n', mse); A tolerance threshold was defined to account for minor numerical differences due to floating-point precision or implementation-specific optimizations. Visualization : We plotted the FFT results from both MATLAB and the module to visually inspect the agreement. Example: plot(frequencies, fft_magnitude_matlab, 'b', 'LineWidth', 1.5); % MATLAB FFT hold on; plot(frequencies, fft_magnitude_module, 'r--', 'LineWidth', 1.5); % Module FFT xlabel('Frequency (Hz)'); ylabel('Magnitude'); legend('MATLAB FFT', 'Module FFT'); title('Comparison of FFT Results'); grid on; Validation Metrics : Mean Squared Error (MSE) : Computed to quantify the difference between the two FFT outputs. Frequency Bin Accuracy : Ensured that the dominant frequencies identified by the module matched those identified by MATLAB. Edge Case Testing : We tested the module with various edge cases, such as: Signals with very low or very high amplitudes. Signals with a single frequency component. Signals with added noise to simulate real-world conditions. These tests ensured that the module behaves correctly under a wide range of scenarios. Automated Testing : We developed a MATLAB script to automate the verification process for multiple test signals. This script generates signals, computes the FFT, compares the results, and logs the metrics.","title":"Validation with Lab-created Samples"},{"location":"Kernel_module/#validation-with-real-world-samples","text":"We then extended our validation process to real-world audio samples , following the same rigorous procedure to ensure the efficiency and accuracy of our module. This step was crucial to verify the module's performance in practical scenarios, where signals often contain noise, harmonics, and other complexities not present in synthetic test cases. Real-World Signal Acquisition : We captured real audio samples using a high-quality microphone and preprocessed them to match the module's input requirements. Examples of samples included musical notes played on various instruments, voice recordings, and environmental sounds. FFT Computation and Comparison : We computed the FFT of these real-world samples using both MATLAB (as the reference) and our module. The results were compared using the same metrics as before: Mean Squared Error (MSE) , and frequency bin accuracy . Observations : The module demonstrated high accuracy for higher frequencies (e.g., notes above C1), with results closely matching those from MATLAB. However, we observed a slightly higher error margin for very low frequencies (e.g., notes in the range C0 to B0). This is likely due to the inherent challenges in accurately resolving low-frequency components with limited sample sizes and the sensitivity of the FFT algorithm at lower frequency ranges. Conclusion on Accuracy : Despite the minor discrepancies at lower frequencies, the module's performance was deemed highly accurate for the majority of the frequency spectrum, particularly in the range most relevant for musical note recognition. The observed errors at lower frequencies are within acceptable limits for our target applications, and we are exploring potential optimizations to further improve accuracy in this range.","title":"Validation with Real-World Samples"},{"location":"Kernel_module/#future-improvements","text":"We plan to add the support to perfom also the inverse fft We plan to investigate techniques to enhance the module's accuracy for very low frequencies , such as: Increasing the sample size or sampling rate. Applying advanced windowing functions to reduce spectral leakage. Incorporating post-processing algorithms to refine frequency detection. This thorough validation process, using both synthetic and real-world signals, confirms that our module is reliable and accurate for its intended applications, with only minor limitations at the extreme low end of the frequency spectrum.","title":"Future Improvements"},{"location":"Qemu/","text":"palle","title":"palle"},{"location":"Qemu/#palle","text":"","title":"palle"},{"location":"Setup/","text":"QEMU & Buildroot Setup Guide This guide provides step-by-step instructions to set up QEMU and Buildroot on Ubuntu, modify necessary files, and use the provided Makefile for automation. Install Required Packages To ensure a smooth setup, install the necessary dependencies using the following command: sudo apt update && sudo apt install -y $(cat requirements.txt) Makefile Guide for QEMU and Buildroot This repository provides a Makefile to automate the process of building and running QEMU and Buildroot for ARM (aarch64) architecture. Available Makefile Targets Run make help to see available targets: Makefile Targets Available targets: env - Create .env file. clone-repos - Clone QEMU and Buildroot repositories. create-setup - Create initial setup, cloning both QEMU and Buildroot. build-buildroot - Build Buildroot for. build-qemu - Configure and build QEMU. run-qemu - Run QEMU. apply-mods - Sync modified files. build-kernel-module - Build kernel module. build-test - Build kernel module test. copy-test - Copy test executable to root filesystem. help - Prints this help message. Build Instructions: Clone this repository: git clone https://github.com/tubbadu/OS-project.git cd OS-project Create .env file: make env Clone Buildroot and QEMU repositories (if you already cloned them, you can move them inside OS-project and skip this step): make clone-repos Create the setup for the build environment: make create-setup Apply the modifications to the source files of QEMU and Buildroot: make apply-mods Build Buildroot (it will take a while): make build-buildroot Build QEMU with the FFT_CORE (it will take a while): make build-qemu Build the kernel module inside Buildroot: make build-kernel-module Cross-compile the test: make build-test Copy the test inside the root filesystem of the buildroot image make copy-test Run the Buildroot image with the modified QEMU: make run-qemu When prompted for a login, type root and press Enter. Congrats, you are now inside the VM! You can install the kernel module with: /opt/install-kernel-module.sh To check that everything is workig correctly you can run the test: /opt/fft_test To run the example program: /opt/fft_example","title":"QEMU &amp; Buildroot Setup Guide"},{"location":"Setup/#qemu-buildroot-setup-guide","text":"This guide provides step-by-step instructions to set up QEMU and Buildroot on Ubuntu, modify necessary files, and use the provided Makefile for automation.","title":"QEMU &amp; Buildroot Setup Guide"},{"location":"Setup/#install-required-packages","text":"To ensure a smooth setup, install the necessary dependencies using the following command: sudo apt update && sudo apt install -y $(cat requirements.txt)","title":"Install Required Packages"},{"location":"Setup/#makefile-guide-for-qemu-and-buildroot","text":"This repository provides a Makefile to automate the process of building and running QEMU and Buildroot for ARM (aarch64) architecture.","title":"Makefile Guide for QEMU and Buildroot"},{"location":"Setup/#available-makefile-targets","text":"Run make help to see available targets:","title":"Available Makefile Targets"},{"location":"Setup/#makefile-targets","text":"Available targets: env - Create .env file. clone-repos - Clone QEMU and Buildroot repositories. create-setup - Create initial setup, cloning both QEMU and Buildroot. build-buildroot - Build Buildroot for. build-qemu - Configure and build QEMU. run-qemu - Run QEMU. apply-mods - Sync modified files. build-kernel-module - Build kernel module. build-test - Build kernel module test. copy-test - Copy test executable to root filesystem. help - Prints this help message.","title":"Makefile Targets"},{"location":"Setup/#build-instructions","text":"Clone this repository: git clone https://github.com/tubbadu/OS-project.git cd OS-project Create .env file: make env Clone Buildroot and QEMU repositories (if you already cloned them, you can move them inside OS-project and skip this step): make clone-repos Create the setup for the build environment: make create-setup Apply the modifications to the source files of QEMU and Buildroot: make apply-mods Build Buildroot (it will take a while): make build-buildroot Build QEMU with the FFT_CORE (it will take a while): make build-qemu Build the kernel module inside Buildroot: make build-kernel-module Cross-compile the test: make build-test Copy the test inside the root filesystem of the buildroot image make copy-test Run the Buildroot image with the modified QEMU: make run-qemu When prompted for a login, type root and press Enter. Congrats, you are now inside the VM! You can install the kernel module with: /opt/install-kernel-module.sh To check that everything is workig correctly you can run the test: /opt/fft_test To run the example program: /opt/fft_example","title":"Build Instructions:"}]}